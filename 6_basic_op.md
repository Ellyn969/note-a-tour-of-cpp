# Chapter 6 -- Basic Operations

# Overview

## 左值右值
### **左值Lvalue**
* **指向内存中特定位置的对象**
    * 可以对左值**取地址** `&obj`
* 有名字，有持久的状态
    * **语句结束之后依然存在**
* **能出现在赋值语句的左侧的值**
* e.g., `int a = 10; // a是左值`
* **左值引用`T&`**
    * 一个现有的、稳定的对象的别名
    * 只能绑定到左值
    * 处理左值：deep copy

### **右值Rvalue**
* **不指向任何持久内存位置的值**
* 是**临时**的
    * 不能对右值取地址
    * **语句结束右值即消失**
* **无法为其赋值的值**
* e.g., `int a = 10； // 10是右值`
* **右值引用`T&&`**
    * 绑定到一个**临时的、将要被销毁**的对象上，要修改/窃取它
    * 只能绑定到右值
    * 处理右值：资源移动



## 基本操作
* **示例：**
    ```cpp
    class X
    public:
        X(sometype); // 普通构造函数
        X(); // 默认构造函数
        X(const X&); // 拷贝构造函数
        X(X&&)； // 移动构造函数
        X& operator=(const X&); // 拷贝赋值操作符：清空目标对象并拷贝：传递左值引用T&
        X& operator=(X&&); // 移动赋值操作符：清空目标对象并移动：传递右值引用T&&
        ~X(); // 析构函数
    ```
    * **默认构造函数**
    * **拷贝构造函数：**
        * 操作：分配新内存，将原对象的数据完整复制过来
        * 参数类型：`Type&`: **左值引用**
            * **复制资源（deep cocy）**
    * **移动构造函数：**
        * 省去了昂贵的复制，无需分配新内存
        * 操作：**将指针指向原对象的内存地址，将原对象的指针悬空**
        * 参数类型：`Type&&`: **右值引用**
            * **转移资源（修改指针所有权）**
    * **拷贝赋值操作符**
    * **移动赋值操作符**
    * **析构函数**
* 对于构造函数：编译器会根据需要自动生成上面做这些成员函数（普通构造函数除外）
    * 如果想要显式使用这些函数的默认实现：`X(const x&) = default; // 显式要求使用默认的拷贝构造函数`, `X(x&&) = default;`
    * 如果想要声明不使用某个函数：`Shape(const Shape&) = delete; // 禁用拷贝构造函数`
        * 如，**类层次结构中的基类往往不允许拷贝**
        * `= delete` 可用于**任意函数**
        * 试图使用被禁用的函数会导致**编译错误**
* 需要被移动/拷贝的情况：  
    * 赋值给其他对象
    * 作为对象初始值
    * 作为函数参数传递
    * 作为函数返回值
    * 作为异常
    * **其中，赋值语句使用拷贝/移动赋值操作符，其他情况使用拷贝/移动构造函数**
* **零法则/经验法则**：
    * **要么定义所有的基本操作函数，要么一个都不定义（全部使用默认设置）**

## 转换
* 接受单个参数的构造函数同时定义了从参数类型到类类型的转换, e.g., `complex z1 = 3.14 // double -> complex class`
* 然而，有的时候我们需要：**只允许显式类型转换**
    * 例如，`Vector v1 = 7`
        * `int 7`不能转换到`vector`
        * 会走单产构造函数：构造7个元素的v1
        * --> 需要规定：不允许隐式地将int转化为vector
    * --> **使用`explicit`关键字**
        * `explicit Vector(int s); // 禁止隐式转换`
        * `Vector v1 = 7; // 编译错误`
        * `Vector v2(7); // 正确`
* 通常，**把接受单个参数地构造函数声明为`explicit`是个好习惯**

## 成员初始值设定项
* **默认成员初始值设定项**：在定义数据成员时提供默认的初始值
    * e.g., 
        ```cpp
        class complex {
            double re = 0.0; 
            double im = 0.0; 
        
        //...
        };
        ```
    * **优先级**：构造函数初始化列表 > 默认成员初始值设定项 > 默认初始化
        * 默认初始化：如果没有提供初始值，内置类型的成员将保持未初始化状态

# 拷贝和移动
* 拷贝“对象”（用户自定义类型 / 内置类型对象）
    * 逐成员复制
## 拷贝容器
* 当一个类被作为**资源句柄**时（即，负责通过指针访问一个对象），采取默认的*逐成员赋值方式*会产生灾难性的错误
    * 示例：
        ```cpp
        void bad_copy(Vector v1) {
            Vector v2 = v1; // 将v1的表层拷贝到v2 -- 共享同一块内存
            // 后续修改其实际上修改了同一块内存

            v1[0] = 2 // 修改v1的第一个元素
            v2[1] = 3 // 修改v2的第二个元素
        }
        // 函数返回时，v1和v2被销毁，释放了同一块内存两次，导致程序崩溃
        ```
* --> 类的拷贝操作可以通过**拷贝构造函数和拷贝赋值操作符**来定义
    * **深拷贝**：**首先为新对象分配独立的内存**，并复制数据
    * recall, 
        * 拷贝构造函数：`Vector(const Vector& a);`
        * 拷贝赋值操作符：`Vector& operator=(const Vector& a);`
    * 具体定义：
        ```cpp
        // 拷贝构造函数
        Vector::Vector(const Vector& a) 
            : sz(a.sz), elem(new double[a.sz]) // 分配新内存
        {
            for (int i = 0; i < sz; ++i)
                elem[i] = a.elem[i]; // 复制数据
        }

        // 拷贝赋值操作符
        Vector& Vector::operator=(const Vector& a) {
            double *p = new double[a.sz]; // 为即将写入的新数据申请一块新内存，大小和a相同

            for (int i = 0; i < a.sz; ++i)
                p[i] = a.elem[i]; // 把a.elem的数据复制到新内存p

            delete[] elem; // 释放当前对象原先持有的旧内存（当前对象自己的elem）
            elem = p; // 把elem改指p
            sz = a.sz;

            return *this;
        }
        ```
        * `this`指针：**指向调用该成员函数的对象本身**。被预定义在成员函数中

## 移动容器
* 对于大容量的容器：拷贝消耗巨大
    * 在函数调用时，我们会选择使用*引用*来减少此类消耗
    * 然而，我们**无法返回局部变量的引用**，如：
        ```cpp
        void f(const Vector& x, const Vector& y, const Vector& z) {
            // ...
            Vector sum = x + y + z; 
            // ...

            // recall, we've defined operator+
            // in this case, we should use operator+ twice
        }
        ```
        * 如果使用前面讨论的**拷贝**：我们会拷贝operator+的返回值，然而，这个值在拷贝之后便不会再用
        * --> **移动语义**：实际上，我们并不需要拷贝这个临时对象，而更想要**移动它**
* 具体实现：
    ```cpp
    Vector::Vector(Vector&& a) // 移动构造函数
        : sz(a.sz), elem(a.elem) 
    {
        a.sz = 0; // 将源对象a置于有效但空的状态
        a.elem = nullptr; // 表示a现在不再拥有任何资源
    }
    ```
    * **移动构造函数不接受`const`实参**：我们正需要“窃取”它的值
* 例如：
    ```cpp
    Vector f(){
        Vector v1(1000); 
        Vector v2(2000);
        Vector v3(3000);

        v3 = v1; // 拷贝赋值操作符：给v3分配一份新的1000大小的内存，并复制v1的数据
        v2 = std::move(v1); // 移动赋值：v1的内存指针被转移到v2，v1被置为空
        
        return v3;
    }
    ```
    * 在函数的返回过程中：`v3`的元素被传递到函数之外，`v3`被销毁。
    * `std::move()`: **将一个左值强制转换为右值引用**：`v1`被当成是右值
        * 当且仅当我们确定不再需要使用某个对象时，才使用`std::move`
        * 使得：我们能对该值进行移动操作

# 资源管理
* 不能/不希望拷贝的情况示例：
    1. **标准库`thread`:**
        * `#include <thread>`
        * 提供**多线程编程支持**
        * `std::thread`表示一个独立的执行线程对象；*在构造时立即开始执行*；
        * 用法：`std::thread t(func, args...); // func是线程函数，args是传递给func的参数，t是线程对象`
        * **不可拷贝，但可移动（移动所有权）**
    2. 含有上百万个`double`类型数据的**Vector**
        * 实际我们只希望能将这批数据拿出来使用，而不是真的想复制一份
    * --> **用移动代替拷贝**：
        ```cpp
        std::vector<thread> my_threads;

        Vector init(int n){
            thread t{heartbeat}; 
            my_threads.push_back(std::move(t)); // 将t移动到vector中，避免拷贝

            Vector v(n);
            for (auto&x : v)
                x = 0.0;
            return v; // 返回v时会调用移动构造函数，而不是拷贝构造函数
        }
        ```
        * `my_threads.push_back(std::move(t));`: t不能被拷贝，**使用`std::move`**
        * `return v;`: 返回v时，编译器会自动调用**移动构造函数**，而不是拷贝构造函数
* **资源句柄&指针：**
    * 指针：`new`, `delete`
    * 资源句柄：
        * e.g., `std::unique_ptr`, `std::shared_ptr`, `vector`, `thread`
        * **RAII:** 创建时：资源自动释放；销毁时：资源自动释放
    * 不要手动管理内存
    * 尽量使用标准库提供的资源管理类（自带管理功能的）
* **资源：**
    * 任何在使用前需要获取和释放的东西
    * 不止内存：文件/线程句柄、锁……
* **垃圾回收机制**

# 操作符重载
* 但不允许创建新的操作符
* 单目操作符（一元运算符）、双目操作符、三目操作符
* 用于对称操作数的操作符：通常应当定义为**非成员函数/独立函数**，以表示对两个操作数平等对待
* 使用移动语义保证返回巨大对象（如matrix）时的高性能

# 常规操作
* 在定义类型时，一部分操作拥有常规定义：
    * 比较操作：`==`, `!=`, `<`, `>`, `<=`, `>=`
    * 容器类操作：`size()`, `empty()`, `clear()`, `begin()`, `end()`
    * *迭代器*和指针操作：`*`, `->`, `++`, `--`
    * 流操作：`<<`, `>>`
    * 函数对象操作：`()`
    * `swap()`
    * 哈希函数：`std::hash<T>`
## 比较
* 双目操作符如 `==` （通常定义为独立函数，且和类存在于同一命名空间）
* `<=>` 三路比较操作符（C++20引入）
    * e.g., 
        ```cpp
        #include <compare>
        class X {
        public:
            auto operator<=>(const X& other) const = default; 
        };

        bool b1 = (r1<=>r2) < 0; // r1 小于 r2
        bool b2 = (r1<=>r2) == 0; // r1 等于 r2
        bool b3 = (r1<=>r2) > 0; // r1 大于 r2
        ```
    * 当定义了**默认的`<=>`**时，编译器会自动生成其他比较操作符
    * 当`<=>`没有被声明为`default`时，不会隐式定义`==`，但`<`等符号会被定义，如：
        ```cpp
        #include <compare>
        class X {
        public:
            int m;
            auto operator<=>(const X& a) const {
                return a.m == m ? 0 : (m < a.m ? -1 : 1);
            }
        };
        ```
        * 表达式`p?x:y`: 如果p为真，结果为x，否则为y
    * --> 大多数标准库模式，如`vector`和`string`，都选择**自定义`<=>`+`==`**:
        * **默认**的`<=>`会检查**每个元素**并以字典顺序比较
        * 此时，独立优化的`==`会更高效：如比较两字符串是否相等时，首先检查长度是否相等

## 容器操作
* 设计容器：风格与标准库容器一致；可以通过句柄并基于基本操作
* 获取容器大小：`size()`函数
* 遍历容器 **【迭代器】**：
    * 一般不用`size()`
    * 使用**迭代器**：`begin()`, `end()`:
        ```cpp
        for (auto it = v.begin(); it != v.end(); ++it) {
            // 使用*it访问元素
        }
        ```
        * `c.begin()`: 返回指向容器第一个元素的迭代器
        * 支持`++it`操作：移动到下一个元素
        * 支持`*it`操作：访问当前元素
        * 用于实现范围for循环：
            ```cpp
            for (auto& x : v) {
                // 使用x访问元素
            }
            ```
        * 用于标准算法，如`sort(v.begin(), v.end());`

## 用户定义字面量 UDL
* 允许为自定义类型定义**字面量后缀**，如：`123s // second类型`；`12.7i // imaginary类型`
    * 使用合适的头文件和命名空间
* 使用字面量操作符定义
    ```cpp
    constexpr complex operator""i(long double im) {
        return {0, im};
    }
    ```
    * `operator""`: 关键字，表示正在定义一个字面量操作符
    * `operator""i`: 定义了一个名为`i`的字面量操作符
        * 标准库一般使用下划线：`_i`
    * `long double im`: 接受一个`long double`类型的参数
    * 返回一个`complex`对象，实部为0，虚部为`im`